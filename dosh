#!/bin/bash
#
# Copyright (c) 2017-2020,2022-2023 GaÃ«l PORTAY
#
# SPDX-License-Identifier: MIT
#

# Called as program loader (shebang #!/usr/bin/dosh)
__="$_"
if [ "$__" != "/bin/bash" ] && [ "$__" = "$1" ]
then
	exec <"$1"
	shift
	set -- -s "$@"
	exec "$0" "$@"
elif [ "$__" != "/bin/bash" ] && [ "$__" = "$2" ]
then
	read -r -a args <<<"$1"
	shift
	exec <"$1"
	shift
	set -- "${args[@]}" -s "$@"
	exec "$0" "$@"
fi

set -e
set -u
set -o pipefail

VERSION="5"

usage() {
	cat <<EOF
Usage: Typical shell commands:
       ${0##*/}    [(-|+)abefhmnuvxC] [(-|+)o shopt] [SCRIPT_FILE  [ARGS...]]
       ${0##*/} -c [(-|+)abefhmnuvxC] [(-|+)o shopt] COMMAND [NAME [ARGS...]]
       ${0##*/} -i [(-|+)abefhmnuvxC] [(-|+)o shopt] [SCRIPT_FILE  [ARGS...]]
       ${0##*/} -s [(-|+)abefhmnuvxC] [(-|+)o shopt]               [ARGS...]

       Advanced dosh container commands:
       ${0##*/} --detach           [OPTIONS]
       ${0##*/} --exec CONTAINER   [OPTIONS] [ARGS...]
       ${0##*/} --attach CONTAINER [OPTIONS]

       Advanced dosh image management commands:
       ${0##*/} --rmi [OPTIONS]
       ${0##*/} --ls
       ${0##*/} --gc

       Extra docker frontend commands:
       ${0##*/} --attach [OPTIONS] [DOCKER_OPTIONS] CONTAINER
       ${0##*/} --kill   [OPTIONS] [DOCKER_OPTIONS] CONTAINER [CONTAINER...]
       ${0##*/} --rm     [OPTIONS] [DOCKER_OPTIONS] CONTAINER [CONTAINER...]

Run a shell as user in a container and bind mount cwd.

POSIX Shell related options:
      -c                        Read commands from command-line.
      -i                        Set interactive.
      -s                        Read commands from standard-input.
      -abefhmnuvxC or -o shopt,
      +abefhmnuvxC or +o shopt  For a more thorough description of shopts,
                                please refers to sh help.

Bash specific options:
      -klprtBDEHIPT or -O shopt,
      +klprtBDEHIPT or +O shopt For a more thorough description of shopts,
                                please refers to bash help.

Dash specific options:
      -pqEIV, +pqEIV            For a more thorough description of shopts,
                                please refers to dash help.

Zsh specific options:
      -0123456789dgklprtwyBDEFGHIJKLMNOPQRSTUVWXYZ,
      +0123456789dgklprtwyBDEFGHIJKLMNOPQRSTUVWXYZ
                                For a more thorough description of shopts,
                                please refers to zsh help.

Docker related options:
      --dockerfile FILE         Path to the Dockerfile to use.
      --context TAR             Path to the context to send to docker daemon.
      --no-auto-context         Disable automatic context sent to docker daemon.
      --no-extra-options        Disable extra options given to docker commands.
      --no-doshprofile          Disable read of ~/.dosh_profile.
      --no-doshrc               Disable read of ./doshrc.
      --directory DIR           Change to directory before doing anything else.
      --working-directory DIR   Working directory inside the container.
      --root                    Run as root.
      --dind                    Run dosh in dosh.
      --home                    Bind mount home directory.
      --mount-options OPTIONS   Set bind mount volume options.
                                For a more thorough description please refers to
                                docker-run(1) manual.
      --shell SHELL             Set shell interpretor.
                                Equivalent to set DOSHELL=<SHELL>.
      --ls                      List images and exit.
      --gc                      Cleanup unused images and exit.
      --build                   Build image.
      --rebuild                 Build image again, verbosely.
                                Equivalent to --build --verbose.
      --rmi                     Remove image and exit.
      --detach                  Detach container.
      --exec CONTAINER          Execute in container.
      --attach CONTAINER        Attach container.
      --kill CONTAINER          Kill container.
      --rm CONTAINER            Remove container.
      --tag                     Print docker tag and exit.
      --dry-run                 Do nothing; echo docker commands.

Miscellaneous options:
      --verbose                 Turn on verbose mode.
      --version                 Print version.
      --help                    Print usage.

Environment variables:
      DOSHELL                   The full pathname to the shell to run in docker
                                image.
                                Equivalent to --shell <SHELL>.

      DOSHLVL                   Incremented by one each time an instance of dosh
                                is started.

      DOSH_DOCKER               The docker executable.

      DOSH_DOCKERFILE           The filename of the Dockerfile to use.
                                Equivalent to --dockerfile <FILE>.

      DOSH_DOCKER_RUN_EXTRA_OPTS
                                Set additionnal parameters to docker run
                                command.

      DOSH_DOCKER_EXEC_EXTRA_OPTS
                                Set additionnal parameters to docker exec
                                command.

      DOSH_DOCKER_ATTACH_EXTRA_OPTS
                                Set additionnal parameters to docker attach
                                command.

      DOSH_DOCKER_KILL_EXTRA_OPTS
                                Set additionnal parameters to docker kill
                                command.

      DOSH_DOCKER_RM_EXTRA_OPTS
                                Set additionnal parameters to docker rm
                                command.

      DOSH_DOCKER_BUILD_EXTRA_OPTS
                                Set additionnal parameters to docker build
                                command.

      DOSH_DOCKER_RMI_EXTRA_OPTS
                                Set additionnal parameters to docker rmi
                                command.
EOF
}

run() {
	# Prepend echo to output the command instead
	if [[ ${dryrun:-} ]]
	then
		# Preserve exec keyword as first argument if set
		if [ "$1" == "exec" ]
		then
			set -- "$1" echo "${@:1}"
		else
			set -- echo "$@"
		fi

		# Preserve spaces in command line if any
		set -- "${@// /\\ }"
	fi

	"$@"
}

checksum() {
	local sha256

	read -r -a sha256 < <(echo -n "$1" | sha256sum -)
	echo "${sha256[0]}"
}

file_checksum() {
	local sha256

	read -r -a sha256 < <(sha256sum "$1" 2>/dev/null || echo "<none>" "$1")
	echo "${sha256[0]}"
}

add_symlink() {
	local file
	local checksum

	file="$(realpath "$1")"
	checksum="$(checksum "$PWD")"
	mkdir -p "$cachedir/$checksum"
	ln -sf "$file" "$cachedir/$checksum/$2"
}

remove_symlink() {
	rm "$cachedir/$1/$2"
	rmdir --ignore-fail-on-non-empty "$cachedir/$1"
}

get_tag() {
	local file
	local checksum

	file="$(realpath "$1")"
	checksum="$(file_checksum "$file")"
	echo "dosh-$checksum"
}

get_images() {
	local image
	local images

	mapfile -t images < <(docker images "dosh-*" --format "{{.Repository}}")

	for image in "${images[@]}"
	do
		local symlink

		for symlink in "$cachedir"/*/"$image"
		do
			local file
			local status
			local checksum
			local dockerfile
			local dockerfile_checksum

			status="Ready"
			file="${symlink%/*}"
			file="${file##*/}"
			checksum="${symlink##*/dosh-}"
			dockerfile="$(readlink "$symlink" || echo "<none>")"
			dockerfile_checksum="$(file_checksum "$dockerfile")"
			if [[ "$dockerfile" == "<none>" ]] || [[ "$dockerfile_checksum" == "<none>" ]]
			then
				status="Deleted"
			elif [[ "$dockerfile_checksum" != "$checksum" ]]
			then
				status="Outdated"
			fi
			if [[ ! -e "$symlink" ]]
			then
				file="<none>"
			fi
			echo "$image" "$file" "$status" "$dockerfile_checksum" "$dockerfile"
		done
	done
}

list() {
	local image
	local images

	mapfile -t images < <(get_images)
	printf "%-69s %-8s %-64s %s\n" "TAG" "STATUS" "CHECKSUM" "DOCKERFILE"

	for image in "${images[@]}"
	do
		local tag
		local file
		local status
		local checksum
		local dockerfile

		read -r tag file status checksum dockerfile _ <<<"$image"
		printf "%-69s %-8s %-64s %s\n" "$tag" "$status" "$checksum" "$dockerfile"
	done
}

prune() {
	local image
	local images
	local unused
	local symlink
	local images_ready
	local images_unused

	mapfile -t images < <(get_images)

	# first pass: store the list of both ready and unused (outdated and deleted) images
	for image in "${images[@]}"
	do
		local tag
		local file
		local status
		local checksum
		local dockerfile

		read -r tag file status checksum dockerfile _ <<<"$image"
		if [[ "$status" == "Ready" ]]
		then
			images_ready+=("$tag")
			continue
		fi

		images_unused+=("$file/$tag")
	done

	# second pass: unlink the outdated images and remove both outdated and deleted images
	for unused in "${images_unused[@]}"
	do
		local tag
		local rmiopts

		# Verify the image is actually unused
		for image in "${images[@]}"
		do
			local tag
			local file
			local status
			local checksum
			local dockerfile

			read -r tag file status checksum dockerfile _ <<<"$image"
			if [[ "$tag" == "${unused##*/}" ]] && [[ "$status" == "Ready" ]]
			then
				break
			fi
		done

		# The image is actually used, skip it...
		if [[ "$tag" == "${unused##*/}" ]] && [[ "$status" == "Ready" ]]
		then
			continue
		fi

		IFS=/ read -r _ tag _ <<<"$unused"

		# Append the extra options if any
		if [ "${DOSH_DOCKER_RMI_EXTRA_OPTS:-}" ]
		then
			rmiopts+=("${DOSH_DOCKER_RMI_EXTRA_OPTS[@]}")
		fi

		run "${docker[@]}" rmi "${rmiopts[@]}" "$tag" "$@"
	done

	# third pass: consolidate the database
	for symlink in "$cachedir"/*/"dosh-"*
	do
		local tag
		local checksum

		if [[ -e "$symlink" ]]
		then
			continue
		fi

		checksum="${symlink%/*}"
		checksum="${checksum##*/}"
		tag="${symlink##*/}"

		remove_symlink "$checksum" "$tag"
	done
}

docker_build() {
	local did
	local files
	local context_file

	if [[ ${DOSH_NOBUILD:-} ]]
	then
		return
	fi

	if [[ ! -e "$1" ]]
	then
		echo "$1: No such Dockerfile"
		exit 1
	fi

	# Inject both user and group id.
	if ! IFS=":" read -r -a did < <(grep '^docker:' /etc/group)
	then
		did=( "$USER" x "${GROUPS[0]}" )
	fi
	cat "$1" - <<EOF >doshfile

USER root
RUN grep -q "^$USER:" /etc/group \
 || groupadd --non-unique --gid ${GROUPS[0]} $USER \
 || addgroup -g ${GROUPS[0]} $USER; \
    grep -q "^$USER:" /etc/passwd \
 || useradd  --non-unique --gid ${GROUPS[0]} --uid $UID --create-home --home-dir $HOME --shell /bin/sh $USER \
 || adduser  -G $USER -u $UID -h $HOME -s /bin/sh -D $USER; \
    grep -q "^dind:" /etc/group \
 || groupadd --non-unique --gid ${did[2]} dind \
 || addgroup -g ${did[2]} dind; \
    grep -q "^dind:x:${did[2]}:.*$USER" /etc/group \
 || usermod  --append --group dind $USER \
 || addgroup $USER dind; \
    if test -d /etc/sudoers.d; then echo "%$USER ALL=(ALL) NOPASSWD: ALL" >>"/etc/sudoers.d/$USER"; fi
EOF

	files=(doshfile)
	context_file="${3:-}"
	if ! [[ ${context_file:-} ]]
	then
		local f
		local word
		local words

		while read -r -a words
		do
			if ! [[ ${words[0]:-} ]]
			then
				continue
			elif [[ ${words[0]^^} =~ ^(ADD|COPY)$ ]]
			then
				# Remove keyword and destination path
				unset 'words[0]'
				unset 'words[-1]'

				for word in "${words[@]}"
				do
					# Skip long option and sources with schema://
					if [[ $word =~ ^-- ]] ||
					   [[ $word =~ ^.*\:// ]]
					then
						continue
					fi

					for f in $word
					do
						files+=("$f")
					done
				done
				unset f
			elif [[ ${words[0]^^} =~ ^ENTRYPOINT$ ]]
			then
				echo "Info: ENTRYPOINT is overridden by dosh"
			fi
		done <doshfile >&2
	fi

	# Append the extra options if any
	if [[ ${DOSH_DOCKER_BUILD_EXTRA_OPTS:-} ]]
	then
		buildopts+=("${DOSH_DOCKER_BUILD_EXTRA_OPTS[@]}")
	fi
	buildopts+=(--build-arg "DOSH_USER=$USER")
	buildopts+=(--build-arg "DOSH_UID=$UID")
	buildopts+=(--build-arg "DOSH_GID=${GROUPS[0]}")
	buildopts+=(--build-arg "DOSH_GROUPS=${GROUPS[*]}")
	buildopts+=(--build-arg "DOSH_HOME=$HOME")

	# Do not send the build context to the daemon if neither ADD nor COPY instructions in Dockerfile.
	if [[ ${#files[@]} -gt 1 ]] && [[ ${no_auto_context:-} ]]
	then
		echo "Info: ADD or COPY sends build context to daemon" >&2
		echo "      Consider option --context <TAR> to speed up the build of image." >&2
		echo "      First, generate the context archive as suggested by the command below:" >&2
		echo "          tar cf context.tar ${files[*]}" >&2
		echo "      Then, run dosh again and tell it to use the context archive:" >&2
		echo "          $0 --context context.tar ${BASH_ARGV[*]}" >&2
		run "${docker[@]}" build "${buildopts[@]}" --tag "$2" --file doshfile .
	else
		if ! [[ ${context_file:-} ]]
		then
			run tar c "${files[@]}"
		else
			run tar rf "$context_file" "doshfile"
			run cat "$context_file"
		fi | \
		run "${docker[@]}" build "${buildopts[@]}" --tag "$2" --file doshfile -
	fi

	rm -f doshfile

	add_symlink "$1" "$2"
}

docker_attach() {
	local attachopts

	# Append the extra options if any
	if [ "${DOSH_DOCKER_ATTACH_EXTRA_OPTS:-}" ]
	then
		attachopts+=("${DOSH_DOCKER_ATTACH_EXTRA_OPTS[@]}")
	fi

	run "${docker[@]}" attach "${attachopts[@]}" "$@"
}

docker_kill() {
	local killopts

	# Append the extra options if any
	if [ "${DOSH_DOCKER_KILL_EXTRA_OPTS:-}" ]
	then
		killopts+=("${DOSH_DOCKER_KILL_EXTRA_OPTS[@]}")
	fi

	run "${docker[@]}" kill "${killopts[@]}" "$@"
}

docker_rm() {
	local rmopts

	# Append the extra options if any
	if [ "${DOSH_DOCKER_RM_EXTRA_OPTS:-}" ]
	then
		rmopts+=("${DOSH_DOCKER_RM_EXTRA_OPTS[@]}")
	fi

	run "${docker[@]}" rm "${rmopts[@]}" "$@"
}

docker_rmi() {
	local rmiopts
	local checksum

	# Append the extra options if any
	if [ "${DOSH_DOCKER_RMI_EXTRA_OPTS:-}" ]
	then
		rmiopts+=("${DOSH_DOCKER_RMI_EXTRA_OPTS[@]}")
	fi

	run "${docker[@]}" rmi "${rmiopts[@]}" "$@"

	checksum="$(checksum "$PWD")"
	remove_symlink "$checksum" "$1"
}

has_positional_parameter() {
	local parameter

	for parameter in "$@"
	do
		if ! [[ "$parameter" =~ ^[-+] ]]
		then
			return 0
		fi
	done

	return 1
}

is_doshopt() {
	if [[ "$1" =~ ^--(no-auto-context|no-extra-options|no-doshprofile|no-doshrc|root|dind|home|ls|gc|build|rebuild|rmi|detach|kill|rm|tag)$ ]]
	then
		return 0
	fi

	return 1
}

is_doshopt_argument() {
	if [[ "$1" =~ ^--(dockerfile|context|directory|working-directory|mount-options|shell|exec|attach)$ ]]
	then
		return 0
	fi

	return 1
}

is_shopt() {
	local dosh

	dosh="${shell=$DOSHELL}"
	dosh="${dosh##*/}"

	# Do not handle -o shoptname here
	# sh (only)
	if [[ "$1" =~ ^-[cis]$ ]] || [[ "$1" =~ ^[-+][abefhmnuvxC]$ ]]
	then
		return 0
	fi

	# bash (specific)
	if [ "$dosh" == "bash" ] && [[ "$1" =~ ^[-+][klprtBDEHIPT]$ ]]
	then
		return 0
	fi

	# dash (specific)
	if [ "$dosh" == "dash" ] && [[ "$1" =~ ^[-+][pqEIV]$ ]]
	then
		return 0
	fi

	# zsh (specific)
	if [ "$dosh" == "zsh" ] && [[ "$1" =~ ^[-+][0123456789dgklprtwyBDEFGHIJKLMNOPQRSTUVWXYZ]$ ]]
	then
		return 0
	fi

	return 1
}

is_shopt_argument() {
	local dosh

	dosh="${shell=$DOSHELL}"
	dosh="${dosh##*/}"

	# sh (only)
	if [[ "$1" =~ ^[-+][o]$ ]]
	then
		return 0
	fi

	# bash (specific)
	if [ "$dosh" == "bash" ] && [[ "$1" =~ ^[-+]O$ ]]
	then
		return 0
	fi

	return 1
}

shopts=()
read -r -a docker <<<"${DOSH_DOCKER[*]:-docker}"
dockerfile="${DOSH_DOCKERFILE:-Dockerfile}"
directory="."
working_directory="$PWD"
opts=()
buildopts=("--quiet")
cachedir="${XDG_CACHE_HOME:-$HOME/.cache}/dosh"
DOSHELL="${DOSHELL:-/bin/sh}"
DOSHLVL="${DOSHLVL:-0}"
while [ "$#" -ne 0 ]
do
	if [ "$1" = "--help" ]
	then
		usage
		exit 0
	elif [ "$1" = "--version" ]
	then
		echo "$VERSION"
		exit
	elif is_doshopt "$1"
	then
		optname="${1//-/_}"
		optname="${optname:2}"
		eval "$optname=1"
	elif is_doshopt_argument "$1"
	then
		optname="${1//-/_}"
		optname="${optname:2}"
		eval "$optname=\"$2\""
		shift
	elif [ "$1" = "--dry-run" ]
	then
		dryrun=true
	elif [ "$1" = "--verbose" ]
	then
		verbose=true
		buildopts=()
	elif is_shopt "$1"
	then
		shopts+=("$1")
		eval "opt_${1:1:1}=1"
	elif is_shopt_argument "$1"
	then
		shopts+=("$1")
		eval "opt_${1:1:1}=\"${2:-1}\""
		if [ $# -gt 1 ]
		then
			shopts+=("$2")
			shift
		fi
	elif [ "$1" = "--" ]
	then
		shift
		break
	else
		break
	fi
	shift
done

# Print the tag and exit
if [[ "${tag:-}" ]]
then
	# Print tag
	get_tag "$directory/$dockerfile"
	exit
fi

# Apply the dosh options to the dosh environment variables
# --shell SHELL to DOSHELL
if [[ ${shell:-} ]]
then
	DOSHELL="$shell"
fi
# --dockerfile FILE to DOSH_DOCKERFILE
if [[ ${dockerfile:-} ]]
then
	DOSH_DOCKERFILE="$dockerfile"
fi
# --no-extra-options resets DOSH_DOCKER_*_EXTRA_OPTS
if [[ ${no_extra_options:-} ]]
then
	DOSH_DOCKER_RUN_EXTRA_OPTS=
	DOSH_DOCKER_EXEC_EXTRA_OPTS=
	DOSH_DOCKER_BUILD_EXTRA_OPTS=
	DOSH_DOCKER_RMI_EXTRA_OPTS=
fi

# converts the DOSH_DOCKER_*_EXTRA_OPTS environment variables to arrays
read -r -a DOSH_DOCKER_RUN_EXTRA_OPTS <<<"${DOSH_DOCKER_RUN_EXTRA_OPTS:-}"
read -r -a DOSH_DOCKER_EXEC_EXTRA_OPTS <<<"${DOSH_DOCKER_EXEC_EXTRA_OPTS:-}"
read -r -a DOSH_DOCKER_BUILD_EXTRA_OPTS <<<"${DOSH_DOCKER_BUILD_EXTRA_OPTS:-}"
read -r -a DOSH_DOCKER_RMI_EXTRA_OPTS <<<"${DOSH_DOCKER_RMI_EXTRA_OPTS:-}"

# Change the current directory
cd "$directory"

# Source the profile files
if [[ ! ${no_doshprofile:-} ]] && [ -e ~/.dosh_profile ]
then
	. ~/.dosh_profile
fi
if [[ ! ${no_doshrc:-} ]] && [ -e ./doshrc ]
then
	. ./doshrc
fi

# List the images and exit
if [[ ${ls:-} ]]
then
	# List images
	list
	exit
fi

# Remove the deleted and outdated images and exit
if [[ ${gc:-} ]]
then
	# Garbage collect unused images
	prune "$@"
	exit
fi

# Attach the container and exit
if [[ ${attach:-} ]]
then
	# Attach a detached container
	docker_attach "$attach" "$@"
	exit
fi

# Kill the container and exit
if [[ ${kill:-} ]]
then
	# Kill a detached container
	docker_kill "$@" >&2
	exit
fi

# Remove the container and exit
if [[ ${rm:-} ]]
then
	# Remove a detached container
	docker_rm "$@" >&2
	exit
fi

# Remove the image and exit
if [[ ${rmi:-} ]]
then
	# Remove image if exist
	tag="$(get_tag "$DOSH_DOCKERFILE")"
	docker_rmi "$tag" "$@" >&2
	exit
fi

# Run in a new container
if ! [[ ${exec:-} ]]
then
	# Rebuild or automatically build the image if it does not exist
	tag="$(get_tag "$DOSH_DOCKERFILE")"
	imageid="$("${docker[@]}" images -q "$tag")"
	if [[ ${build:-} ]] || [[ ${rebuild:-} ]] || ! [[ ${imageid:-} ]]
	then
		# Reset the quiet option when the image does not exist or it rebuild or if verbose option is set
		if ! [[ ${imageid:-} ]] || [[ ${rebuild:-} ]] || [[ ${verbose:-} ]]
		then
			buildopts=()
		fi
		docker_build "$DOSH_DOCKERFILE" "$tag" "${context:-}" >&2
	fi

	# Detach the container
	if [[ ${detach:-} ]]
	then
		opts+=("--detach")
	# Remove the container on exit
	else
		opts+=("--rm")
	fi

	# Bind mount the home directory
	if [[ ${home:-} ]]
	then
		opts+=("--volume" "$HOME:/home/$USER:${mount_options:-rw}")
	# Bind mount the current working directory
	else
		opts+=("--volume" "$PWD:$PWD:${mount_options:-rw}")
	fi
fi

# Set the current user privileges for dosh-in-dosh
if [[ ${dind:-} ]]
then
	opts+=("--user" "$UID:dind")
	opts+=("--volume" "/var/run/docker.sock:/var/run/docker.sock")
	opts+=("--volume" "$0:/bin/dosh:ro")
# Set the current user privileges
elif ! [[ ${root:-} ]]
then
	opts+=("--user" "$UID:${GROUPS[0]}")
fi

# Set the interactive options
if [[ ${opt_i:-} ]] || [[ ${opt_s:-} ]] || ! has_positional_parameter "$@"
then
	opts+=("--interactive")

	# Allocate a pseudo-TTY if stdin/stderr are TTY
	if [ -t 0 ] && [ -t 2 ]
	then
		opts+=("--tty")
	fi
fi

# Prepend the shell options if any
if [ ${#shopts[*]} -gt 0 ]
then
	set -- "${shopts[@]:-}" "$@"
fi

# Set the working directory
opts+=("--workdir" "$working_directory")

# Incremented by one level instance
opts+=("--env" "DOSHLVL=$((DOSHLVL+1))")

# Execute in an existing container and exit
if [[ ${exec:-} ]]
then
	# Append the extra options if any
	if [[ ${DOSH_DOCKER_EXEC_EXTRA_OPTS:-} ]]
	then
		opts+=("${DOSH_DOCKER_EXEC_EXTRA_OPTS[@]}")
	fi

	run exec "${docker[@]}" exec "${opts[@]}" "$exec" "$DOSHELL" "$@"

	# Never reached!
	exit 127
fi

# Run in a new container
opts+=("--entrypoint" "$DOSHELL")
if [[ ${verbose:-} ]]
then
	echo "$tag"
fi >&2

# Append the extra options if any
if [[ ${DOSH_DOCKER_RUN_EXTRA_OPTS:-} ]]
then
	opts+=("${DOSH_DOCKER_RUN_EXTRA_OPTS[@]}")
fi
run exec "${docker[@]}" run "${opts[@]}" "$tag" "$@"

# Never reached!
exit 127
